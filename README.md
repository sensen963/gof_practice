# About

- 『ちょうぜつソフトウェア設計入門』(著:田中ひさてる)の第8章デザインパターンを読んだのでそれの復習用に記す
- 基本的にはコードをほぼ写経し実行できる単位まで変換する
- そのうえで使い勝手や使用用途などについて考察を加える
- 使用言語はOOPであれば何でも良かったが最近触っていなかったので復習がてらKotlinを選択する

# Pattern

## Iterator

### 概要

- 何かコレクションを一つづつ取り出す際にインターフェースとして切り出すパターン
- 今どきの言語は言語仕様に組み込まれているのが殆どなのでイテレータのインターフェースを書くのはまあまずないかと思う
  - 言語自体が吸収して今更何言ってるんだと思いたくなるパターンの一つ
- イテレータはイテレータだがイテレータを評価した際に値になる処理が必要なのが実装言語仕様の差が出やすいポイントなきがする
  - 例えばC++だと`foeach(auto iter: set) cout(*iter)`みたいにforeachで回すとイテレータを取得できて，ポインタ演算子で値を評価できる
  - C#だとイテレータという型ではなく`IEnumerable`という列挙型を用意してforeachで回す
    - `yield return`で暗黙的に遅延実行が書きやすいのは個人的に感心した記憶がある
- arrayみたいに有限個である必要もなく，初期化時に内容がすべて確定している必要もない
    - だから1から続く無限個の整数列とかも作れる
    - 遅延実行の例で関数型言語っぽいよね

## Template Method

### 概要

- 外から呼び出されるインターフェースを切り出し，幾つか実装において共通部分がある場合に使用される
- 共通部分はインターフェースを継承した抽象クラスに実装し，ロジック特有の処理に関しては抽象メソッドにしておいて具象クラスに実装させる．
- 同じものは継承元が書いてくれたらそれを再利用できるというナイーブなパターン

### メリット

- 具象クラスを分けず同じ抽象クラスを継承することで共通ロジックをコピペしなくて済む
- 共通処理をヘルパーメソッドに書き出すのに比べて，具象クラスの実装時に呼び出す処理すら書かなくても良くなる
- インターフェース，抽象クラスを使用しており初学者がつまづきがちな文法用途の解説に丁度よい

### デメリット

- 外部から操作できるのがインターフェース単位なので抽象クラス，具象クラス単位で少しでも異なるI/Fができない
- I/F上かなり強い制限になる
- 共通処理に関しても綺麗に一元化できるとは限らず，追加要次第ではほとんど具象クラスに持っていかれるのもあるある
- 個人的にはデバッガでコードを追っているときにどの具象クラスのロジックが動いているのかがわかりにくいので苦労した記憶がある
  - これはTemplateパターンに限った話ではないが

## Bridge

### 概要

- Templateは一軸を主軸にして継承をさせていたが，Bridgeでは複数軸の継承を考える
- 多くの言語ではclassの単一継承を選択しているので複数のクラスを同時には継承できない
  - Interfaceはできる
  - 結局実装が衝突しないための仕組み
- 複数軸の性質を見たい場合はis-aではなくhas-aの考えを持ちインスタンスの組み合わせで表現する発想

### メリット

- 多軸での性質を表現するため各オブジェクトは各軸のみに集中するだけで良い
- 各軸の組み合わせはオブジェクト作成時に決めたら良いので組み合わせ爆発は起きない

### デメリット

- それらの性質が独立でない場合十分に分けられない
  - それの判断が難しそう 
  - あとから他の要素に依存した性質があってというパターンが出てきそう
- 性質をオブジェクトで表現する以上インスタンスの等価性を実装する必要あり
  - 毎度かくのは面倒
  - 今回の例の場合Enumを使えばよいのではという気がした